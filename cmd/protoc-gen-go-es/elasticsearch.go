package main

import (
	"fmt"
	esProto "github.com/devexps/go-micro/v2/elastic/es"
	dayProto "github.com/devexps/go-micro/v2/elastic/type"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/timestamppb"
	"os"
)

const (
	elasticPackage       = protogen.GoImportPath("gopkg.in/olivere/elastic.v6")
	reflectPackage       = protogen.GoImportPath("reflect")
	timePackage          = protogen.GoImportPath("time")
	ptypesPackage        = protogen.GoImportPath("github.com/golang/protobuf/ptypes")
	elasticHelperPackage = protogen.GoImportPath("github.com/devexps/go-micro/elastic")
	stringsPackage       = protogen.GoImportPath("strings")
	logPackage           = protogen.GoImportPath("github.com/devexps/go-micro/v2/log")
	jsonPackage          = protogen.GoImportPath("encoding/json")
	fmtPackage           = protogen.GoImportPath("fmt")
	elasticAlias         = "elastic"
	reflectAlias         = "reflect"
	timeAlias            = "time"
	timestampAlias       = "timestamp"
	ptypesAlias          = "ptypes"
	elasticHelperAlias   = "elasticHelper"
	stringsAlias         = "strings"
	logAlias             = "log"
	jsonAlias            = "json"
	fmtAlias             = "fmt"
)

var (
	mapPackageName = map[string]string{}
)

func addImport(g *protogen.GeneratedFile, pkgPath protogen.GoImportPath, pkgAlias string) {
	pkgGoName := g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: pkgPath})
	if _, ok := mapPackageName[pkgAlias]; !ok {
		mapPackageName[pkgAlias] = pkgGoName
	}
}

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Messages) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_es.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-es. DO NOT EDIT.")
	g.P("// versions:")
	g.P(fmt.Sprintf("// - protoc-gen-go-es %s", release))
	//g.P("// - protoc             ", protocVersion(gen))
	g.P("package ", file.GoPackageName)
	generateFileContent(gen, file, g)
	return g
}

// generateFileContent generates the elasticsearch mapping
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Messages) == 0 {
		return
	}

	esDescriptor := &esWrapper{}
	messages := getAllMessages(file.Messages)
	for _, message := range messages {
		msgDesc := &messageDescription{
			MessageName: message.GoIdent.GoName,
		}
		esMapping := generateEsMapping(message, g)
		buildQuery := generateBuildQuery(message, g)
		getEsMap := generateGetEsMap(message, g)

		if esMapping != nil || buildQuery != nil || getEsMap != nil {
			msgDesc.EsMapping = esMapping
			msgDesc.BuildQuery = buildQuery
			msgDesc.GetEsMap = getEsMap
			esDescriptor.MessageDescriptions = append(esDescriptor.MessageDescriptions, msgDesc)
		}
	}
	esDescriptor.MapPackageName = mapPackageName
	g.P(esDescriptor.execute())
}

func getAllMessages(messages []*protogen.Message) []*protogen.Message {
	allMessages := []*protogen.Message{}

	for _, message := range messages {
		allMessages = append(allMessages, message)
		allMessages = append(allMessages, getAllMessages(message.Messages)...)
	}

	return allMessages
}

func generateEsMapping(msg *protogen.Message, g *protogen.GeneratedFile) *esMapping {
	esMapping := &esMapping{}

	fieldDescs := []*FieldDescription{}
	for _, field := range msg.Fields {

		fieldExten := getFieldEsIfAny(field)
		fv := getFieldQueryIfAny(field)
		if fieldExten == nil {
			continue
		}
		fieldDesc := &FieldDescription{
			FieldName: field.GoName,
		}

		if field.Message != nil {
			fieldDesc.TypeName = string(field.Message.Desc.Name())
		}

		fieldDescs = append(fieldDescs, fieldDesc)
		defer func() {
			if fieldDesc.TagName == "" {
				_, _ = fmt.Fprintf(os.Stderr, "\u001B[31mERR\u001B[m: Tag name of field %s, message %s is empty \n", fieldDesc.FieldName, msg.Desc.Name())
				os.Exit(2)
			}
		}()

		if fv != nil {
			if fv.GetMatchPhrasePrefix() != "" {
				fieldDesc.TagName = fv.GetMatchPhrasePrefix()
				fieldDesc.EsType = EsMatchPhrasePrefix
			} else if fv.GetMatchPhrasePrefixLeft() != "" {
				fieldDesc.TagName = fv.GetMatchPhrasePrefixLeft()
				fieldDesc.EsType = EsMatchPhrasePrefixLeft
			} else if fv.GetMatchPhrasePrefixRight() != "" {
				fieldDesc.TagName = fv.GetMatchPhrasePrefixRight()
				fieldDesc.EsType = EsMatchPhrasePrefixRight
			} else if fv.GetMatch() != "" {
				fieldDesc.TagName = fv.GetMatch()
				fieldDesc.EsType = EsMatch
			} else if fv.GetMatchPrefix() != "" {
				fieldDesc.TagName = fv.GetMatchPrefix()
				fieldDesc.EsType = EsMatchPrefix
			}
			continue
		}
		fieldDesc.TagName = fieldExten.GetEs()
		isRepeated := field.Desc.Cardinality() == protoreflect.Repeated
		if field.Message != nil {
			if isRepeated {
				fieldDesc.EsType = RepeatedMessage
				addImport(g, elasticHelperPackage, elasticHelperAlias)
			} else {
				//timestamp
				if isTimestampType(field) || isDateType(field) {
					fieldDesc.EsType = Date
				} else {
					fieldDesc.EsType = Message
					addImport(g, elasticHelperPackage, elasticHelperAlias)
				}
			}
		} else if field.Enum != nil || isRepeated {
			fieldDesc.EsType = KeyWord
		} else {
			if fieldDesc.TagName == "" {
				fieldDesc.TagName = fieldExten.GetStoreZeroValue()
			}

			switch field.Desc.Kind() {
			case protoreflect.BoolKind:
				fieldDesc.EsType = Boolean
			case protoreflect.Int32Kind:
				fieldDesc.EsType = Int32
			case protoreflect.Int64Kind:
				fieldDesc.EsType = Int64
			case protoreflect.StringKind:
				fieldDesc.EsType = KeyWord
			case protoreflect.FloatKind:
				fieldDesc.EsType = Float
			case protoreflect.DoubleKind:
				fieldDesc.EsType = Double
			default:
				_, _ = fmt.Fprintf(os.Stderr, "\u001B[31mWARN\u001B[m: Unknow Type %s of Field %s \n", fieldDesc.FieldName, field.Desc.Kind().String())
				os.Exit(2)
			}
		}
	}
	if len(fieldDescs) == 0 {
		return nil
	}
	esMapping.FieldDescriptions = fieldDescs
	return esMapping
}

func generateBuildQuery(msg *protogen.Message, g *protogen.GeneratedFile) *buildQuery {
	buildQuery := &buildQuery{}
	queryDescriptions := []*QueryDescription{}
	for _, field := range msg.Fields {
		fv := getFieldQueryIfAny(field)
		if fv == nil {
			continue
		}
		fQueryZero := getFieldQueryZeroValue(field)
		queryDesc := &QueryDescription{
			VariableName: "this." + field.GoName,
		}
		if field.Message != nil {
			queryDesc.TypeName = string(field.Message.Desc.Name())
		}

		isRepeated := field.Desc.Cardinality() == protoreflect.Repeated
		queryDesc.CheckNilFunc = "IsNil"
		if fQueryZero != nil {
			queryDesc.CheckNilFunc = "IsDefaultZeroValue"
		}

		if fv.GetMatchPhrasePrefix() != "" {
			queryDesc.TagName = fv.GetMatchPhrasePrefix()
			queryDesc.QueryType = MatchPhrasePrefix
			addImport(g, fmtPackage, fmtAlias)
			addImport(g, stringsPackage, stringsAlias)
		} else if fv.GetMatchPhrasePrefixLeft() != "" {
			queryDesc.TagName = fv.GetMatchPhrasePrefixLeft()
			queryDesc.QueryType = MatchPhrasePrefixLeft
			addImport(g, fmtPackage, fmtAlias)
		} else if fv.GetMatchPhrasePrefixRight() != "" {
			queryDesc.TagName = fv.GetMatchPhrasePrefixRight()
			queryDesc.QueryType = MatchPhrasePrefixRight
			addImport(g, fmtPackage, fmtAlias)
		} else if fv.GetWildcard() != "" {
			queryDesc.TagName = fv.GetWildcard()
			queryDesc.QueryType = Wildcard
			addImport(g, stringsPackage, stringsAlias)
			addImport(g, fmtPackage, fmtAlias)
		} else if fv.GetWildcardLeft() != "" {
			queryDesc.TagName = fv.GetWildcardLeft()
			queryDesc.QueryType = WildcardLeft
			addImport(g, fmtPackage, fmtAlias)
		} else if fv.GetWildcardRight() != "" {
			queryDesc.TagName = fv.GetWildcardRight()
			queryDesc.QueryType = WildcardRight
			addImport(g, fmtPackage, fmtAlias)
		} else if fv.GetTerms() != "" {
			queryDesc.TagName = fv.GetTerms()
			if isRepeated {
				queryDesc.QueryType = Terms
			} else {
				queryDesc.QueryType = Term
			}
		} else if fv.GetMatch() != "" {
			queryDesc.TagName = fv.GetMatch()
			queryDesc.QueryType = Match
		} else if fv.GetMatchPrefix() != "" {
			queryDesc.TagName = fv.GetMatchPrefix()
			queryDesc.QueryType = MatchPrefix
		} else if fv.GetNotTerms() != "" {
			queryDesc.TagName = fv.GetNotTerms()
			if isRepeated {
				queryDesc.QueryType = NotTerms
			} else {
				queryDesc.QueryType = NotTerm
			}
		} else if fv.GetGte() != "" {
			queryDesc.TagName = fv.GetGte()
			queryDesc.QueryType = TmstampGte
			buildQuery.InitRangeQuery = true
		} else if fv.GetGt() != "" {
			queryDesc.TagName = fv.GetGt()
			queryDesc.QueryType = TmstampGt
			buildQuery.InitRangeQuery = true
		} else if fv.GetLte() != "" {
			queryDesc.TagName = fv.GetLte()
			queryDesc.QueryType = TmstampLte
			buildQuery.InitRangeQuery = true
		} else if fv.GetLt() != "" {
			queryDesc.TagName = fv.GetLt()
			queryDesc.QueryType = TmstampLt
			buildQuery.InitRangeQuery = true
		} else if fv.GetTermsZero() != "" {
			queryDesc.TagName = fv.GetTermsZero()
			queryDesc.QueryType = TermsZero
		} else {
			_, _ = fmt.Fprintf(os.Stderr, "\u001B[31mERROR\u001B[m: tag name of field %s can not be empty: %v, \n", queryDesc.VariableName, fv)
			os.Exit(2)
		}

		queryDescriptions = append(queryDescriptions, queryDesc)
	}

	if len(queryDescriptions) == 0 {
		return nil
	}

	buildQuery.QueryDescriptions = queryDescriptions
	addImport(g, elasticHelperPackage, elasticHelperAlias)
	addImport(g, logPackage, logAlias)
	addImport(g, elasticPackage, elasticAlias)
	addImport(g, jsonPackage, jsonAlias)

	return buildQuery
}

func generateGetEsMap(msg *protogen.Message, g *protogen.GeneratedFile) *getEsMap {
	getEsMap := &getEsMap{}
	getEsMapDescs := []*GetEsMapDescription{}
	for _, field := range msg.Fields {
		fieldEs := getFieldEsIfAny(field)
		if fieldEs == nil {
			continue
		}

		getEsMapDesc := &GetEsMapDescription{
			FieldName:    field.GoName,
			VariableName: "this." + field.GoName,
		}
		if fieldEs.GetEs() != "" {
			getEsMapDesc.CheckNilFunc = "IsNil"
			getEsMapDesc.TagName = fieldEs.GetEs()
			if field.Message != nil {
				if isTimestampType(field) {
					getEsMapDesc.EsMapType = Timestamp
					addImport(g, ptypesPackage, ptypesAlias)
					addImport(g, timePackage, timeAlias)
				} else if isDateType(field) {
					getEsMapDesc.EsMapType = EsMapTypeDate
				} else if field.Desc.Cardinality() == protoreflect.Repeated {
					getEsMapDesc.EsMapType = RepeatedStruct
				} else {
					getEsMapDesc.EsMapType = Struct
				}
			} else {
				getEsMapDesc.EsMapType = SimpleType
			}

		} else if fieldEs.GetStoreZeroValue() != "" {
			if field.Message != nil {
				_, _ = fmt.Fprintf(os.Stderr, "\u001B[31mERR\u001B[m: Type %s is not supported for zero value storing!!!\n", field.Desc.Kind().String())
				os.Exit(2)
			}
			getEsMapDesc.CheckNilFunc = "IsDefaultZeroValue"
			getEsMapDesc.TagName = fieldEs.GetStoreZeroValue()
			getEsMapDesc.EsMapType = SimpleType
		} else {
			_, _ = fmt.Fprintf(os.Stderr, "\u001B[31mERR\u001B[m: Tag name of field %s, message %s is empty \n", field.GoName, msg.GoIdent.GoName)
			os.Exit(2)
		}
		getEsMapDescs = append(getEsMapDescs, getEsMapDesc)
	}

	if len(getEsMapDescs) == 0 {
		return nil
	}
	getEsMap.GetEsMapDescriptions = getEsMapDescs
	addImport(g, elasticHelperPackage, elasticHelperAlias)
	return getEsMap
}

func getFieldEsIfAny(field *protogen.Field) *esProto.FieldEs {
	if field.Desc.Options() != nil {
		v := proto.GetExtension(field.Desc.Options(), esProto.E_Es)
		if v.(*esProto.FieldEs) != nil {
			return (v.(*esProto.FieldEs))
		}
	}
	return nil
}

func getFieldQueryIfAny(field *protogen.Field) *esProto.FieldQuery {
	if field.Desc.Options() != nil {
		v := proto.GetExtension(field.Desc.Options(), esProto.E_Query)
		if v.(*esProto.FieldQuery) != nil {
			return (v.(*esProto.FieldQuery))
		}
	}
	return nil
}

func getFieldQueryZeroValue(field *protogen.Field) *esProto.FieldZeroValueQuery {
	if field.Desc.Options() != nil {
		v := proto.GetExtension(field.Desc.Options(), esProto.E_QueryZero)
		if v.(*esProto.FieldZeroValueQuery) != nil {
			return (v.(*esProto.FieldZeroValueQuery))
		}
	}
	return nil
}

func isTimestampType(field *protogen.Field) bool {
	timestamp := &timestamppb.Timestamp{}
	//timestamp
	if field.Desc.Message().FullName() == timestamp.ProtoReflect().Descriptor().FullName() {
		return true
	}
	return false
}

func isDateType(field *protogen.Field) bool {
	date := &dayProto.Date{}
	if field.Desc.Message().FullName() == date.ProtoReflect().Descriptor().FullName() {
		return true
	}
	return false
}
